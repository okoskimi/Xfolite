/*
 * This file is part of: Xfolite (J2ME XForms client)
 *
 * Copyright (c) 2010 Nokia Corporation and/or its subsidiary(-ies).
 *
 * Contact: Oskari Koskimies <oskari.koskimies@nokia.com>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published
 * by the Free Software Foundation; either version 2.1 of the License, or
 * (at your option) any later version.
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU Lesser General Public License for more details.
 * You should have received a copy of the GNU Lesser
 * General Public License along with this program.
 * If not, see <http://www.gnu.org/licenses/>.
 */

package com.nokia.xfolite.xml.xpath;import java.util.Stack;import java.util.Vector;import com.nokia.xfolite.xml.dom.Attr;import com.nokia.xfolite.xml.dom.DOMException;import com.nokia.xfolite.xml.dom.Node;public class XPathEvaluator {        static protected final NodeSet EMPTY_NODESET = new NodeSet();        private XPathParser m_parser;        private Vector m_functionLibraries;        private Stack m_FocusStack;        private ResultCache m_resultCache;        private NodeSet m_Dependencies;        private XPathContext m_CurrentFocus;    private Node m_OriginalContext;        private NodeSet m_resultNodeSet;        private NodeSet m_inputNodeSet;    private int m_inputNodeSetIndex;    private Object m_CurrentAxisOperand;        public int RecursionCounter=0;        public static int VectorCreationCounter=0;        public XPathEvaluator()    {        m_parser = new XPathParser();        m_resultCache = new ResultCache(10);        m_FocusStack = new Stack();        m_functionLibraries = new Vector();         m_functionLibraries.addElement(new XPathCoreFunctionLibrary());    }               /**     * Creates a parsed XPath expression with resolved namespaces. This is      * useful when an expression will be reused in an application since it      * makes it possible to compile the expression string into a more      * efficient internal form and preresolve all namespace prefixes which      * occur within the expression.createExpression should not raise      * exceptions about type coercion.This was already fixed in the public      * draft.     * @param expression The XPath expression string to be parsed.     * @param resolver The <code>resolver</code> permits translation of      *   prefixes within the XPath expression into appropriate namespace URIs     *   . If this is specified as <code>null</code>, any namespace prefix      *   within the expression will result in <code>DOMException</code>      *   being thrown with the code <code>NAMESPACE_ERR</code>.     * @return The compiled form of the XPath expression.     * @exception XPathException     *   INVALID_EXPRESSION_ERR: Raised if the expression is not legal      *   according to the rules of the <code>XPathEvaluator</code>i     * @exception DOMException     *   NAMESPACE_ERR: Raised if the expression contains namespace prefixes      *   which cannot be resolved by the specified      *   <code>XPathNSResolver</code>.     */    public XPathExpression createExpression(String expression,                                             XPathNSResolver resolver)                                            throws XPathException, DOMException    {                ParseNode compiledExpression = m_parser.Parse(expression,resolver);                        return new XPathExpression (this,compiledExpression);    }        /**     * Evaluates an XPath expression string and returns a result of the      * specified type if possible.An exception needs to be raised when an      * XPath expression is evaluated on a node such as an EntityReference      * which cannot serve as an XPath context node.Done: NOT_SUPPORTED_ERR.A      * description is needed of what happens when the node passed to the      * evaluation function is a Text or CDATASection in the DOM case where      * the text may be fragmented between text nodes.Done.Eliminate the      * evaluate method from XPathEvaluator, forcing everyone to create      * expressions.No change.Any implementor can easily implement it by      * creating an expression. Having it available as a separate routine is      * a convenience and may be an optimization as well in some cases.Revert      * to multiple evaluateAs methods instead of passing a type code.No      * change.This is an alternative which eliminates a method argument      * while adding methods, but the type code is used to designate the type      * on returns anyway and using it as an argument to specify any coercion      * seems natural to many.Error exceptions are needed when there is a      * mismatch between the implementation of XPathEvaluator and the context      * node being evaluated.Done: WRONG_DOCUMENT_ERRConcern that the XPath      * API should only support natural results of XPath expression, without      * convenience coercion or alternative representations. Any special      * thing such as ordering should be added later to resultNo change.We      * have significant use cases for returning alternative types and      * representations by explicit request in advance.Eliminate the reusable      * result argument.No change.No. We have use cases for it, and there is      * already an implementation showing there is nothing wrong with it.     * State that the XPathNSResolver argument may be a function in      * Javascript.Yes.There is an exception when there is a problem parsing      * the expression, but none when there is a problem evaluating the      * expression.No change.If the expression parsing was OK, then the worst      * that can happen is an empty result is returned.When requesting any      * type, the implementation should be permitted to return any type of      * node set, i.e. ordered or unordered, it finds convenient.No change.     * The iterator it returns may contain ordered results, but identifying      * it as such produces undesirable results, because it would create      * complexity for the user -- requiring checking two types to see if the      * result was a node set -- or incompatibility caused by assuming it was      * always the one returned by a particular implementation the developer      * was using.NAMESPACE_ERR description is not appropriate to the way it      * is being used here.Make the description of NAMESPACE_ERR in the core      * specification more general.Should the INVALID_EXPRESSION_ERR be      * INVALID_SYNTAX_ERR?No change.We can improve the description of the      * error, but the name is appropriate as-is. It covers not only syntax      * errors but expression errors, such as when the implementation has no      * custom functions or variables but the expression specifies custom      * functions or variables.     * @param expression The XPath expression string to be parsed and      *   evaluated.     * @param contextNode The <code>context</code> is context node for the      *   evaluation of this XPath expression. If the XPathEvaluator was      *   obtained by casting the <code>Document</code> then this must be      *   owned by the same document and must be a <code>Document</code>,      *   <code>Element</code>, <code>Attribute</code>, <code>Text</code>,      *   <code>CDATASection</code>, <code>Comment</code>,      *   <code>ProcessingInstruction</code>, or <code>XPathNamespace</code>      *   node. If the context node is a <code>Text</code> or a      *   <code>CDATASection</code>, then the context is interpreted as the      *   whole logical text node as seen by XPath, unless the node is empty      *   in which case it may not serve as the XPath context.     * @param resolver The <code>resolver</code> permits translation of      *   prefixes within the XPath expression into appropriate namespace URIs     *   . If this is specified as <code>null</code>, any namespace prefix      *   within the expression will result in <code>DOMException</code>      *   being thrown with the code <code>NAMESPACE_ERR</code>.     * @param type If a specific <code>type</code> is specified, then the      *   result will be coerced to return the specified type relying on      *   XPath type conversions and fail if the desired coercion is not      *   possible. This must be one of the type codes of      *   <code>XPathResult</code>.     * @param result The <code>result</code> specifies a specific      *   <code>XPathResult</code> which may be reused and returned by this      *   method. If this is specified as <code>null</code>or the      *   implementation cannot reuse the specified result, a new      *   <code>XPathResult</code> will be constructed and returned.     * @return The result of the evaluation of the XPath expression.     * @exception XPathException     *   INVALID_EXPRESSION_ERR: Raised if the expression is not legal      *   according to the rules of the <code>XPathEvaluator</code>i     *   <br>TYPE_ERR: Raised if the result cannot be converted to return the      *   specified type.     * @exception DOMException     *   NAMESPACE_ERR: Raised if the expression contains namespace prefixes      *   which cannot be resolved by the specified      *   <code>XPathNSResolver</code>.     *   <br>WRONG_DOCUMENT_ERR: The Node is from a document that is not      *   supported by this XPathEvaluator.     *   <br>NOT_SUPPORTED_ERR: The Node is not a type permitted as an XPath      *   context node.     *        */    public XPathResult evaluate(String expression,                                 Node contextNode,                                 XPathNSResolver resolver,                                 byte type)                                throws XPathException, DOMException    {        ParseNode compiledExpression = m_parser.Parse(expression,resolver);        return new XPathResult(                SimpleEvaluate(compiledExpression,                        new XPathContext(contextNode, 1, 1),                        type,                        null));    }        /**     * Evaluates an XPath expression string and returns a result of the      * specified type if possible.An exception needs to be raised when an      * XPath expression is evaluated on a node such as an EntityReference      * which cannot serve as an XPath context node.Done: NOT_SUPPORTED_ERR.A      * description is needed of what happens when the node passed to the      * evaluation function is a Text or CDATASection in the DOM case where      * the text may be fragmented between text nodes.Done.Eliminate the      * evaluate method from XPathEvaluator, forcing everyone to create      * expressions.No change.Any implementor can easily implement it by      * creating an expression. Having it available as a separate routine is      * a convenience and may be an optimization as well in some cases.Revert      * to multiple evaluateAs methods instead of passing a type code.No      * change.This is an alternative which eliminates a method argument      * while adding methods, but the type code is used to designate the type      * on returns anyway and using it as an argument to specify any coercion      * seems natural to many.Error exceptions are needed when there is a      * mismatch between the implementation of XPathEvaluator and the context      * node being evaluated.Done: WRONG_DOCUMENT_ERRConcern that the XPath      * API should only support natural results of XPath expression, without      * convenience coercion or alternative representations. Any special      * thing such as ordering should be added later to resultNo change.We      * have significant use cases for returning alternative types and      * representations by explicit request in advance.Eliminate the reusable      * result argument.No change.No. We have use cases for it, and there is      * already an implementation showing there is nothing wrong with it.     * State that the XPathNSResolver argument may be a function in      * Javascript.Yes.There is an exception when there is a problem parsing      * the expression, but none when there is a problem evaluating the      * expression.No change.If the expression parsing was OK, then the worst      * that can happen is an empty result is returned.When requesting any      * type, the implementation should be permitted to return any type of      * node set, i.e. ordered or unordered, it finds convenient.No change.     * The iterator it returns may contain ordered results, but identifying      * it as such produces undesirable results, because it would create      * complexity for the user -- requiring checking two types to see if the      * result was a node set -- or incompatibility caused by assuming it was      * always the one returned by a particular implementation the developer      * was using.NAMESPACE_ERR description is not appropriate to the way it      * is being used here.Make the description of NAMESPACE_ERR in the core      * specification more general.Should the INVALID_EXPRESSION_ERR be      * INVALID_SYNTAX_ERR?No change.We can improve the description of the      * error, but the name is appropriate as-is. It covers not only syntax      * errors but expression errors, such as when the implementation has no      * custom functions or variables but the expression specifies custom      * functions or variables.     * @param expression The XPath expression string to be parsed and      *   evaluated.     * @param context The <code>context</code> is context node for the      *   evaluation of this XPath expression. If the XPathEvaluator was      *   obtained by casting the <code>Document</code> then this must be      *   owned by the same document and must be a <code>Document</code>,      *   <code>Element</code>, <code>Attribute</code>, <code>Text</code>,      *   <code>CDATASection</code>, <code>Comment</code>,      *   <code>ProcessingInstruction</code>, or <code>XPathNamespace</code>      *   node. If the context node is a <code>Text</code> or a      *   <code>CDATASection</code>, then the context is interpreted as the      *   whole logical text node as seen by XPath, unless the node is empty      *   in which case it may not serve as the XPath context.     *   The context also includes the current context position and context size.     *   This is used by e.g. XSLT or XFORMS to set the current position     *   and size in a repeating structure.     * @param resolver The <code>resolver</code> permits translation of      *   prefixes within the XPath expression into appropriate namespace URIs     *   . If this is specified as <code>null</code>, any namespace prefix      *   within the expression will result in <code>DOMException</code>      *   being thrown with the code <code>NAMESPACE_ERR</code>.     * @param type If a specific <code>type</code> is specified, then the      *   result will be coerced to return the specified type relying on      *   XPath type conversions and fail if the desired coercion is not      *   possible. This must be one of the type codes of      *   <code>XPathResult</code>.     * @param result The <code>result</code> specifies a specific      *   <code>XPathResult</code> which may be reused and returned by this      *   method. If this is specified as <code>null</code>or the      *   implementation cannot reuse the specified result, a new      *   <code>XPathResult</code> will be constructed and returned.     * @return The result of the evaluation of the XPath expression.     * @exception XPathException     *   INVALID_EXPRESSION_ERR: Raised if the expression is not legal      *   according to the rules of the <code>XPathEvaluator</code>i     *   <br>TYPE_ERR: Raised if the result cannot be converted to return the      *   specified type.     * @exception DOMException     *   NAMESPACE_ERR: Raised if the expression contains namespace prefixes      *   which cannot be resolved by the specified      *   <code>XPathNSResolver</code>.     *   <br>WRONG_DOCUMENT_ERR: The Node is from a document that is not      *   supported by this XPathEvaluator.     *   <br>NOT_SUPPORTED_ERR: The Node is not a type permitted as an XPath      *   context node.     */    public XPathResult evaluate(String expression,                                 XPathContext context,                                XPathNSResolver resolver,                                 byte type)                                throws XPathException, DOMException    {        ParseNode compiledExpression = m_parser.Parse(expression,resolver);        return new XPathResult(                SimpleEvaluate(compiledExpression,                        new XPathContext(context),                        type,                        null));    }            public void AddFunctionLibrary(XPathFunctionLibrary functionLibrary)    {        m_functionLibraries.addElement(functionLibrary);    }        protected Object SimpleEvaluate(ParseNode expressionTree,                                    XPathContext context,                                    byte type,                                    NodeSet Dependencies) throws XPathException    {        m_Dependencies = Dependencies;        RecursionCounter=0;        VectorCreationCounter = 0;                m_OriginalContext = context.contextNode;        Object result = StartEvaluation(expressionTree, context);        reset(); // very important for objects reusing                switch(type)        {        case XPathResult.BOOLEAN:            return XPathCoreFunctionLibrary.boolean_function(result);        case XPathResult.NUMBER:            return XPathCoreFunctionLibrary.number_function(result);        case XPathResult.STRING:            return XPathCoreFunctionLibrary.string_function(result);        default:            return result;        }       }         private void reset()    {           m_FocusStack.removeAllElements();           m_resultCache.ClearCache();         m_Dependencies = null;        m_CurrentFocus =null;        m_OriginalContext = null;    }                private void PushFocus(XPathContext f)    {        m_CurrentFocus = f;        m_FocusStack.push(f);    }        private void PopFocus()    {        m_FocusStack.pop();        m_CurrentFocus = m_FocusStack.empty()? null: (XPathContext) m_FocusStack.peek();    }        private Object StartEvaluation(ParseNode node, XPathContext focus) throws XPathException    {        PushFocus(focus);        Object result = RecursiveEvaluation(node);        PopFocus();        return result;    }        private Object RecursiveEvaluation(ParseNode node) throws XPathException    {                  //CONSTRUCT & COMBINE      Object result = EvaluateNode(node,EMPTY_NODESET);            ParseNode curr_sibling = node.Sibling();      while (curr_sibling!=null)      {          // FILTER          if (result instanceof NodeSet)          {        	  result = DoFiltering((NodeSet)result,curr_sibling);          }                    curr_sibling = curr_sibling.Sibling();      }                   return result;        }        /**     * DoFiltering is used for the filtering process that is needed in the case of predicates and axis steps.     * The process works by unioning all nodeset resulting from the evaluating the sibling expression (predicate      * or axis step) with every node in the input nodeset as the context node     * @param node_set     * @param sibling     * @return     */    private NodeSet DoFiltering(NodeSet node_set,ParseNode sibling)    {        byte sibling_type = sibling.Op();    	m_resultNodeSet =EMPTY_NODESET; //initialization for the result collection nodeset    	    	// The following code shortcuts the implementation of the axis steps by using whole nodeset    	// as a context instead of using single context nodes and unioning the resulting nodeset    	boolean use_shortcut = node_set.getLength()>1;    SHORTCUT:    	if (use_shortcut)    	{    		m_CurrentAxisOperand = sibling.Child(0);        	m_inputNodeSet = node_set;        	m_inputNodeSetIndex=0;        	    		switch(sibling_type)    		{    		case Token.OP_FORWARD_AXIS_CHILD:    			ChildAxisStep_ContextNodeSet();    			break;	    		    		case Token.OP_FORWARD_AXIS_DESCENDENT:    			DescendentAxisStep_ContextNodeSet();    			break;    		    		// TODO: Performance of this shortcut (for the // operator) should be evaluated more carefully.    		// It seems it often does not help and may even perform worse than the default implementation    		case Token.OP_FORWARD_AXIS_DESCENDENT_OR_SELF:    			DescendentOrSelfAxisStep_ContextNodeSet();    			break;    			    		case Token.OP_REVERSE_AXIS_PARENT:    			ParentAxisStep_ContextNodeSet();    			break;    			    		case Token.OP_FORWARD_AXIS_FOLLOWING_SIBLING:    			FollowingSiblingAxisStep_ContextNodeSet();    			break;    			    		case Token.OP_FORWARD_AXIS_FOLLOWING:    			FollowingAxisStep_ContextNodeSet();    			break;    			    		case Token.OP_REVERSE_AXIS_PRECEDING:    			PrecedingAxisStep_ContextNodeSet();    			break;    		    		default:    			break SHORTCUT; //shortcut not applicable    		}    		    		return m_resultNodeSet;    	}        		int NS_size = node_set.getLength();		NodeSet newNodeSet = EMPTY_NODESET;		for (int i=0; i < NS_size ;i++)          {              PushFocus(                    new XPathContext(                            node_set.item(i),                            sibling_type==Token.OP_REVERSE_PREDICATE? NS_size-i : i+1,                            NS_size) );            Object obj = EvaluateNode(sibling,newNodeSet);            PopFocus();                        if (obj==m_resultNodeSet) // if this optimization is used            {                newNodeSet = (NodeSet) obj;            }            else if (obj instanceof NodeSet)            {                if (newNodeSet==EMPTY_NODESET)                    newNodeSet = (NodeSet) obj;                else                    newNodeSet.Union((NodeSet) obj);            }          }        return newNodeSet;    }    /** * EvaluateNode is the main evaluation method. it operates recursively by evaluating all the children node * expressions and then applying the operator of the node to the results of the child nodes evaluation. * The method implements a caching mechanism for nodes that are independent of the context of evaluation, * employing a greedy algorithm that caches only the largest independent branches of the expression tree. * An expression is only cached if it is context independent and its parent is not cachable * @param node * @param AppendtoNodeSet * @return */	private Object EvaluateNode(ParseNode node,NodeSet AppendtoNodeSet)    {        RecursionCounter++;        // CONSTRUCT        int childcount = node.getChildCount();        Vector childrenresults = (childcount>0)? new Vector(childcount):null;                     if (node.isCachable())           {        	  // if the node is cachable, then its children are certainly not cachable,         	  // so they need to be calculated        	  for (int i=0; i < childcount ;i++)              {                  Object childresult = RecursiveEvaluation(node.Child(i));                                                //Dependencies calculation                  if (m_Dependencies!=null && childresult instanceof NodeSet) {                    m_Dependencies.Union((NodeSet) childresult);                  }                                    childrenresults.addElement(childresult);              }            }else          {        	  // node is not cachable, therefore cache any children nodes that are context independent        	  for (int i=0; i < childcount ;i++)              {                  ParseNode curr_child = node.Child(i);                  Object childresult;                  if (!curr_child.isCachable()                    ||(childresult = m_resultCache.LookupCache(curr_child))==null)                  {                      childresult = RecursiveEvaluation(curr_child);                                            // Dependencies calculation                      if (m_Dependencies!=null && childresult instanceof NodeSet) {                        m_Dependencies.Union((NodeSet) childresult);                      }                      //Add to the cache                      if (curr_child.isCachable())                          m_resultCache.AddtoCache(curr_child, childresult);                  }                  childrenresults.addElement(childresult);              }           }          // COMBINE          return applyOperator(node, childrenresults,AppendtoNodeSet);    }            private Object applyOperator(ParseNode node,Vector Operands,NodeSet AppendtoNodeSet) throws XPathException    {        m_resultNodeSet = AppendtoNodeSet;                switch(node.Op())        {        case Token.OP_NOP:            if (node instanceof LiteralNode)                return ((LiteralNode) node).LiteralValue();            else if (node instanceof NumberNode)                return new Double(((NumberNode) node).NumberValue());            else return node;        case Token.OP_SELECT_ROOT:            {            if (m_resultNodeSet == EMPTY_NODESET)                m_resultNodeSet = new NodeSet(m_CurrentFocus.contextNode.getOwnerDocument());            else                m_resultNodeSet.AddNode(m_CurrentFocus.contextNode.getOwnerDocument());            return m_resultNodeSet;            }                case Token.OP_FORWARD_AXIS_CHILD:            {            m_CurrentAxisOperand = Operands.elementAt(0);        	ChildAxisStep();            return m_resultNodeSet;            }                case Token.OP_FORWARD_AXIS_SELF:            {        	m_CurrentAxisOperand = Operands.elementAt(0);        	SelfAxisStep();            return m_resultNodeSet;            }                case Token.OP_FORWARD_AXIS_DESCENDENT:            {        	m_CurrentAxisOperand = Operands.elementAt(0);        	DescendentAxisStep();            return m_resultNodeSet;            }                case Token.OP_FORWARD_AXIS_DESCENDENT_OR_SELF:            {        	m_CurrentAxisOperand = Operands.elementAt(0);        	DescendentOrSelfAxisStep();            return m_resultNodeSet;            }                    case Token.OP_REVERSE_AXIS_PARENT:            {        	m_CurrentAxisOperand = Operands.elementAt(0);        	ParentAxisStep();            return m_resultNodeSet;             }                    case Token.OP_REVERSE_AXIS_ANCESTOR:            {        	m_CurrentAxisOperand = Operands.elementAt(0);        	AncestorAxisStep();            return m_resultNodeSet;             }                case Token.OP_REVERSE_AXIS_ANCESTOR_OR_SELF:            {        	m_CurrentAxisOperand = Operands.elementAt(0);        	AncestorOrSelfAxisStep();            return m_resultNodeSet;             }                case Token.OP_FORWARD_AXIS_ATTRIBUTE:            {        	m_CurrentAxisOperand = Operands.elementAt(0);        	AttributeAxisStep();            return m_resultNodeSet;            }                    case Token.OP_FORWARD_AXIS_FOLLOWING_SIBLING:            {        	m_CurrentAxisOperand = Operands.elementAt(0);        	FollowingSiblingAxisStep();            return m_resultNodeSet;            }                case Token.OP_REVERSE_AXIS_PRECEDING_SIBLING:            {        	m_CurrentAxisOperand = Operands.elementAt(0);        	PrecedingSiblingAxisStep();            return m_resultNodeSet;            }                    case Token.OP_FORWARD_AXIS_FOLLOWING:            {        	m_CurrentAxisOperand = Operands.elementAt(0);        	FollowingAxisStep();            return m_resultNodeSet;            }                case Token.OP_REVERSE_AXIS_PRECEDING:            {        	m_CurrentAxisOperand = Operands.elementAt(0);        	PrecedingAxisStep();            return m_resultNodeSet;            }                                case Token.OP_OR:            {            Boolean B = XPathCoreFunctionLibrary.boolean_function(Operands.elementAt(0));            if (B.booleanValue())                return B;            else                return XPathCoreFunctionLibrary.boolean_function(Operands.elementAt(1));            }                    case Token.OP_AND:            {            Boolean B = XPathCoreFunctionLibrary.boolean_function(Operands.elementAt(0));            if (!B.booleanValue())                return B;            else                return XPathCoreFunctionLibrary.boolean_function(Operands.elementAt(1));            }                case Token.OP_EQ:        case Token.OP_NEQ:        case Token.OP_LTE:        case Token.OP_LT:        case Token.OP_GTE:        case Token.OP_GT:            return new Boolean(GeneralComparison(node.Op(),Operands.elementAt(0),Operands.elementAt(1)));                    case Token.OP_PLUS:            if (Operands.size()==1)            {                return new Double(XPathCoreFunctionLibrary.number_function(Operands.elementAt(0)).doubleValue());            }else if (Operands.size()==2)            {                return new Double( XPathCoreFunctionLibrary.number_function(Operands.elementAt(0)).doubleValue()                                +  XPathCoreFunctionLibrary.number_function(Operands.elementAt(1)).doubleValue());            }else throw new RuntimeException("+ operator expects 1 or 2 operands");                case Token.OP_MINUS:            if (Operands.size()==1)            {                return new Double( - XPathCoreFunctionLibrary.number_function(Operands.elementAt(0)).doubleValue());            }else if (Operands.size()==2)            {                return new Double( XPathCoreFunctionLibrary.number_function(Operands.elementAt(0)).doubleValue()                                -  XPathCoreFunctionLibrary.number_function(Operands.elementAt(1)).doubleValue());            }else throw new RuntimeException("- operator expects 1 or 2 operands");                case Token.OP_MULT:            return new Double( XPathCoreFunctionLibrary.number_function(Operands.elementAt(0)).doubleValue()                            * XPathCoreFunctionLibrary.number_function(Operands.elementAt(1)).doubleValue());        case Token.OP_MOD:            return new Double( XPathCoreFunctionLibrary.number_function(Operands.elementAt(0)).doubleValue()                            %  XPathCoreFunctionLibrary.number_function(Operands.elementAt(1)).doubleValue());                    case Token.OP_DIV:            return new Double( XPathCoreFunctionLibrary.number_function(Operands.elementAt(0)).doubleValue()                            /  XPathCoreFunctionLibrary.number_function(Operands.elementAt(1)).doubleValue());                case Token.OP_PREDICATE:        case Token.OP_REVERSE_PREDICATE:            {            Object operand = Operands.elementAt(0);            if (operand instanceof Double)            {                if ( ((Double)operand).intValue() ==m_CurrentFocus.contextPosition)                {                    if (m_resultNodeSet == EMPTY_NODESET)                        m_resultNodeSet = new NodeSet(m_CurrentFocus.contextNode);                    else                        m_resultNodeSet.AddNode(m_CurrentFocus.contextNode);                }            }            else if (XPathCoreFunctionLibrary.boolean_function(operand).booleanValue())            {                if (m_resultNodeSet == EMPTY_NODESET)                    m_resultNodeSet = new NodeSet(m_CurrentFocus.contextNode);                else                    m_resultNodeSet.AddNode(m_CurrentFocus.contextNode);            }            return m_resultNodeSet;            }        case Token.OP_UNION:        {        	/*        	System.out.println("************************* XPath Union:");        	for (int i=0; i<Operands.size(); i++) {        		System.out.println("Operand " + i + ":");        		Object op = Operands.elementAt(i);        		System.out.println("Class: " + op.getClass().getName());        		if (op instanceof NodeSet) {        			NodeSet ns = (NodeSet) op;        			System.out.println("NodeSet length: " + ns.getLength());        			for (int k=0; k < ns.getLength(); k++) {        				Node n = ns.item(k);        				System.out.println("Node " + k + ": " + n.getLocalName()  + "(" + n.getOwnerDocument().hashCode() + ") = " + n.getText());        			}        		}        	}        	*/        	//remove all empty nodesets        	while (Operands.removeElement(EMPTY_NODESET));        	        	int operands_count = Operands.size();        	if (operands_count>1) {        		NodeSet res = UnionOperator(Operands);        		/*    			System.out.println("Result NodeSet length: " + res.getLength());    			for (int k=0; k < res.getLength(); k++) {    				Node n = res.item(k);    				System.out.println("Node " + k + ": " + n.getLocalName() + " = " + n.getText());    			}    			*/    			return res;        	} else if (operands_count == 1) {        		return Operands.elementAt(0);        	} else {        		return EMPTY_NODESET;        	}        }                    case Token.OP_FUNCTION_CALL:        {            ExpandedNameNode FunctionName;                        if (Operands.size() > 0 &&                Operands.elementAt(0) instanceof ExpandedNameNode)            {                FunctionName = (ExpandedNameNode) Operands.elementAt(0);            }            else throw new RuntimeException("Valid xpath function name (QName) expected for function call");                        int args_count = Operands.size()-1;            for (int i = 0; i < m_functionLibraries.size(); i++)            {                XPathFunctionLibrary FuncLib = (XPathFunctionLibrary) m_functionLibraries.elementAt(i);                int FunctionIndex = FuncLib.RecognizeFunction(FunctionName,args_count);                if (FunctionIndex>=0)                    return FuncLib.EvaluateIndexedFunction(FunctionIndex,m_CurrentFocus,Operands, m_OriginalContext);            }            throw new RuntimeException("function " + FunctionName.getLocalName() + " not recognized");        }                }        return node;    }            /**     * Union operator has been implemented in great detail to maintain document order in the resulting     * nodeset. The operator performs a walkthrough through the whole document and picks up nodes     * along the way that might be found in any nodeset. The algorithm assumes that the input nodeset     * are in document order themselves, which makes it possible for the algorithm to check only the first     * unchecked node in the input nodeset. By doing so, the complexity of this algorithm is dependent on     * n * m (where n is the number of nodes in the document, and m is the number of unioned nodeset)     * in preference to n * m * l (where l is the average length of nodesets) if the algorithm has to      * search for nodes inside input nodesets     *      * NOTE: Unfortunately it requires nodesets to be from the same document and still did not work correctly,     * so it was replaced with a simple algorithm that addes nodes one by one to result nodeset and checks     * it for duplicates each time.     *      * @param Operands     * @return     * @throws XPathException     */    private NodeSet UnionOperator(Vector Operands)throws XPathException    {    	    	NodeSet result = new NodeSet();    	int operands_count = Operands.size();    	    	for (int i = 0; i < operands_count; i++) {    		Object curr_object = Operands.elementAt(i);			if (curr_object instanceof NodeSet)			{				result.Union((NodeSet) curr_object);			}			else throw new XPathException(XPathException.TYPE_ERR,"Nodesets expected for union operations");		}    	return result;    	    	    	/* The below code, while more correct in that it maintains document order, does not always work correctly and requires    	 * nodesets to be in the same document    	int operands_count = Operands.size();    	    	NodeSet[] Union_input_sets= new NodeSet[operands_count];    	int[] Union_indices = new int[operands_count];    	    	for (int i = 0; i < operands_count; i++) {    		Object curr_object = Operands.elementAt(i);			if (curr_object instanceof NodeSet)			{				Union_input_sets[i] =(NodeSet) curr_object;				Union_indices[i]=0;			}			else throw new XPathException(XPathException.TYPE_ERR,"Nodesets expected for union operations");		}    	    	NodeSet result =EMPTY_NODESET;    	Node curr_node = m_CurrentFocus.contextNode.getOwnerDocument();    	while (curr_node!=null)    	{    		// test if the current node is found on the current indices of union nodesets    		// also advance the Union indices by 1 for any nodeset in which the curr_node is found    		for (int j=0;j<operands_count;j++)    		{    			NodeSet curr_input_nodeset=Union_input_sets[j];    			int curr_index = Union_indices[j];    			    			if ( curr_index < curr_input_nodeset.getLength()    					&& curr_node == curr_input_nodeset.item(curr_index))    			{    				if (result== EMPTY_NODESET)    					result = new NodeSet(curr_node);                    else                    	result.AddNode(curr_node);    				Union_indices[j]++;    			}    		}    		    		// then test for the attributes of the current node    		int attr_count = curr_node.getAttributeCount();        	for (int i=0;i<attr_count;i++)        	{        		Attr curr_attr = curr_node.getAttribute(i);        		for (int j=0;j<operands_count;j++)        		{        			NodeSet curr_input_nodeset=Union_input_sets[j];        			int curr_index = Union_indices[j];        			        			if ( curr_index < curr_input_nodeset.getLength()        					&& curr_attr == curr_input_nodeset.item(curr_index))        			{        				if (result== EMPTY_NODESET)        					result = new NodeSet(curr_attr);                        else                        	result.AddNode(curr_attr);        				Union_indices[j]++;        			}        		}        	}        	        	// walk down the next node in document order excluding attributes        	Node first_child = curr_node.getFirstChild();        	if (first_child!=null) //1. a first child        	{        		curr_node = first_child;        	}        	else        	{        		Node next_sibling = curr_node.getNextSibling();        		if (next_sibling!=null) //2. otherwise, a sibling            	{            		curr_node = next_sibling;            	}            	else            	{            		Node parent= curr_node.getParentNode();            		Node parent_next_sibling = null;            		while (parent!=null && parent_next_sibling==null)            		{            			parent_next_sibling = parent.getNextSibling();             			parent = parent.getParentNode();            		}            		curr_node = parent_next_sibling; //3. otherwise the closest non-null ancestor's sibling            	}        	}    	}    	    	return result;    	*/    }    /** * Child axis step for an m_inputNodeset used as the context nodeset * */        private void ChildAxisStep_ContextNodeSet()    {    	while (m_inputNodeSetIndex<m_inputNodeSet.getLength())        {	        	testNode_ChildAxis(m_inputNodeSet.item(m_inputNodeSetIndex));        }    }/** * tests a node for a child axis adding all its children to the result nodeset if it is the current node * in the input nodeset and then calls itself recursively for every child node regardless if it is the * current node in the input nodeset or not. A prerequisite for calling this function is that *  m_inputNodeSetIndex < m_inputNodeSet.getLength(); * @param n */        private void testNode_ChildAxis(Node n)    {		boolean n_is_currentnode = n==m_inputNodeSet.item(m_inputNodeSetIndex);		boolean nodes_remaining = true; // must be otherwise last statement will have thrown index out of bound exception		if (n_is_currentnode)		{			m_inputNodeSetIndex++; // this node is processed			nodes_remaining = m_inputNodeSetIndex<m_inputNodeSet.getLength();		}				int children_count = n.getChildCount();	    for (int i=0;i<children_count;i++)	    {	    	Node childnode = n.getChild(i);	    		    	if (n_is_currentnode)		    	{	    		NodeTestAppendifSuccessful(childnode,Node.ELEMENT_NODE);	    	}	        	    	if (nodes_remaining)	        {	        	testNode_ChildAxis(childnode);	        }	    }    }        private void DescendentAxisStep_ContextNodeSet()    {    	while (m_inputNodeSetIndex<m_inputNodeSet.getLength())        {	        	CollectDescendents(m_inputNodeSet.item(m_inputNodeSetIndex++));        }    }     private void DescendentOrSelfAxisStep_ContextNodeSet()    {    	while (m_inputNodeSetIndex<m_inputNodeSet.getLength())        {	        	NodeTestAppendifSuccessful(m_inputNodeSet.item(m_inputNodeSetIndex),Node.ELEMENT_NODE);        	CollectDescendents(m_inputNodeSet.item(m_inputNodeSetIndex++));        }    }        private void CollectDescendents(Node testnode)    {        int children_count = testnode.getChildCount();        for (int i=0;i<children_count;i++)        {            Node childnode = testnode.getChild(i);            NodeTestAppendifSuccessful(childnode,Node.ELEMENT_NODE);            if (m_inputNodeSetIndex<m_inputNodeSet.getLength()            		&& childnode==m_inputNodeSet.item(m_inputNodeSetIndex))            {            	m_inputNodeSetIndex++;            }            CollectDescendents(childnode);        }    }            private void ParentAxisStep_ContextNodeSet()    {    	if (m_inputNodeSetIndex<m_inputNodeSet.getLength())        {	    		ParentIterator(m_inputNodeSet.item(m_inputNodeSetIndex).getOwnerDocument());        }    }    /**     * walks down the descendents of node n and adds any node that is a parent of a current node     * in the input nodeset. A prerequisite for the function is that:     * m_inputNodeSetIndex < m_inputNodeSet.getLength()     * @param n     */        private void ParentIterator(Node n)    {    	int attr_count = n.getAttributeCount();    	int inputNodeSet_length = m_inputNodeSet.getLength();    	boolean node_tested = false;    	for (int i=0;i<attr_count;i++)    	{    		Attr curr_attr = n.getAttribute(i);    		    		if (curr_attr ==m_inputNodeSet.item(m_inputNodeSetIndex))            {    			m_inputNodeSetIndex++;            	if (!node_tested)            	{            		NodeTestAppendifSuccessful(n,Node.ELEMENT_NODE);            		node_tested = true;            	}            }    	}    	    	    	int children_count = n.getChildCount();        for (int i=0;i<children_count;i++)        {            Node childnode = n.getChild(i);                        if (childnode==m_inputNodeSet.item(m_inputNodeSetIndex))            {            	m_inputNodeSetIndex++;            	if (!node_tested)            	{            		NodeTestAppendifSuccessful(n,Node.ELEMENT_NODE);            		node_tested = true;            	}            }            if (m_inputNodeSetIndex < inputNodeSet_length)            {            	ParentIterator(childnode);            }        }    }           private void FollowingSiblingAxisStep_ContextNodeSet()    {    	while (m_inputNodeSetIndex<m_inputNodeSet.getLength())        {	    		IterateFollowingSibling(m_inputNodeSet.item(m_inputNodeSetIndex++));        }    }        private void IterateFollowingSibling(Node n)    {        Node curr_sibling = n.getNextSibling();        while  (curr_sibling!=null)        {        	NodeTestAppendifSuccessful(curr_sibling,Node.ELEMENT_NODE);        	        	if (m_inputNodeSetIndex<m_inputNodeSet.getLength()            		&& curr_sibling==m_inputNodeSet.item(m_inputNodeSetIndex))            {            	m_inputNodeSetIndex++;            }            curr_sibling = curr_sibling.getNextSibling();        }            }/** * The following axis step for context nodeset is implemented by applying following axis step on the first * node in the input nodeset * */        private void FollowingAxisStep_ContextNodeSet()    {    	int NS_size= m_inputNodeSet.getLength();    	    	if (NS_size>0)        {	    		    		PushFocus(                    new XPathContext(                    		m_inputNodeSet.item(0),1,                            NS_size) );            FollowingAxisStep();            PopFocus();            m_inputNodeSetIndex++;        }    }    /*** The Preceding axis step for context nodeset is implemented by applying Preceding axis step on the last* node in the input nodeset**/        private void PrecedingAxisStep_ContextNodeSet()    {    	int NS_size= m_inputNodeSet.getLength();    	    	if (NS_size>0)        {	    		PushFocus(                    new XPathContext(                    		m_inputNodeSet.item(NS_size-1),NS_size,                            NS_size) );            PrecedingAxisStep();            PopFocus();            m_inputNodeSetIndex++;        }    }        private void SelfAxisStep()    {        Node curr_node = m_CurrentFocus.contextNode;        NodeTestAppendifSuccessful(curr_node,Node.ELEMENT_NODE);    }            private void ChildAxisStep()    {        Node curr_node = m_CurrentFocus.contextNode;                int children_count = curr_node.getChildCount();        for (int i=0;i<children_count;i++)        {            Node childnode = curr_node.getChild(i);            NodeTestAppendifSuccessful(childnode,Node.ELEMENT_NODE);        }            }        private void DescendentAxisStep()    {        Node curr_node = m_CurrentFocus.contextNode;                int children_count = curr_node.getChildCount();        for (int i=0;i<children_count;i++)        {            Node childnode = curr_node.getChild(i);            NodeTestAppendifSuccessful(childnode,Node.ELEMENT_NODE);                        Node oldcontext = m_CurrentFocus.contextNode;            m_CurrentFocus.contextNode = childnode;            DescendentAxisStep();            m_CurrentFocus.contextNode = oldcontext;        }    }        private void DescendentOrSelfAxisStep()    {        SelfAxisStep();        DescendentAxisStep();    }        private void ParentAxisStep()    {        Node curr_node = m_CurrentFocus.contextNode;        Node parentnode = curr_node.getNodeType()== Node.ATTRIBUTE_NODE?                    ((Attr) curr_node).getOwnerElement()                    :curr_node.getParentNode();        NodeTestAppendifSuccessful(parentnode,Node.ELEMENT_NODE);    }        private void AncestorAxisStep()    {        Node curr_node = m_CurrentFocus.contextNode;        Node parentnode = curr_node.getNodeType()== Node.ATTRIBUTE_NODE?                    ((Attr) curr_node).getOwnerElement()                    :curr_node.getParentNode();                if (parentnode!=null)        {            Node oldcontext = m_CurrentFocus.contextNode;            m_CurrentFocus.contextNode = parentnode;            AncestorAxisStep();            m_CurrentFocus.contextNode = oldcontext;        }                        NodeTestAppendifSuccessful(parentnode,Node.ELEMENT_NODE);       }        private void AncestorOrSelfAxisStep()    {        AncestorAxisStep();        SelfAxisStep();    }        private void FollowingSiblingAxisStep()    {        Node curr_sibling = m_CurrentFocus.contextNode.getNextSibling();        while  (curr_sibling!=null)        {                    	NodeTestAppendifSuccessful(curr_sibling,Node.ELEMENT_NODE);            curr_sibling = curr_sibling.getNextSibling();        }            }        private void PrecedingSiblingAxisStep()    {               Node curr_sibling = m_CurrentFocus.contextNode.getPreviousSibling();        if  (curr_sibling!=null)        {            Node oldcontext = m_CurrentFocus.contextNode;            m_CurrentFocus.contextNode = curr_sibling;            PrecedingSiblingAxisStep();            m_CurrentFocus.contextNode = oldcontext;                        NodeTestAppendifSuccessful(curr_sibling,Node.ELEMENT_NODE);        }    }        private void FollowingAxisStep()    {        Node next_sibling = m_CurrentFocus.contextNode.getNextSibling();        while (next_sibling!=null)        {            Node oldcontext = m_CurrentFocus.contextNode;            m_CurrentFocus.contextNode = next_sibling;            DescendentOrSelfAxisStep();            m_CurrentFocus.contextNode = oldcontext;                        next_sibling = next_sibling.getNextSibling();        }                        Node parentnode = m_CurrentFocus.contextNode.getParentNode();        if (parentnode!=null)        {            Node oldcontext = m_CurrentFocus.contextNode;            m_CurrentFocus.contextNode = parentnode;            FollowingAxisStep();            m_CurrentFocus.contextNode = oldcontext;        }    }        private void PrecedingAxisStep()    {        Node parentnode = m_CurrentFocus.contextNode.getParentNode();        if (parentnode!=null)        {            Node curr_context = m_CurrentFocus.contextNode;            m_CurrentFocus.contextNode = parentnode;            PrecedingAxisStep();            m_CurrentFocus.contextNode = curr_context;                        Node curr_sibling = parentnode.getFirstChild();            while (curr_sibling!=curr_context)            {                m_CurrentFocus.contextNode = curr_sibling;                DescendentOrSelfAxisStep();                m_CurrentFocus.contextNode = curr_context;                curr_sibling = curr_sibling.getNextSibling();            }        }    }            private void AttributeAxisStep()    {        Node curr_node = m_CurrentFocus.contextNode;        int attribute_count = curr_node.getAttributeCount();        for (int i=0;i<attribute_count;i++)        {            Attr Attrnode = curr_node.getAttribute(i);            NodeTestAppendifSuccessful(Attrnode,Node.ATTRIBUTE_NODE);        }    }        private void NodeTestAppendifSuccessful(Node n,byte principalnodetype)    {            	boolean add_node = false;    	if (n!=null)        {            byte nodetype = n.getNodeType();                        if (m_CurrentAxisOperand instanceof ExpandedNameNode)            	add_node= (nodetype == principalnodetype                         && NameTest((ExpandedNameNode) m_CurrentAxisOperand, n));            else if (m_CurrentAxisOperand instanceof ParseNode)            	add_node= NodeTypeTest((ParseNode) m_CurrentAxisOperand,nodetype);        }    	    	if (add_node)    	{            if (m_resultNodeSet == EMPTY_NODESET)                m_resultNodeSet = new NodeSet(n);            else                m_resultNodeSet.AddNode(n);        }    }        private boolean NodeTypeTest(ParseNode pn, byte nodetype)    {        byte op = pn.Op();                return op == Token.OP_NT_NODE        || (op ==Token.OP_NT_TEXT && nodetype == Node.TEXT_NODE)        || (op ==Token.OP_NT_COMMENT && nodetype == Node.COMMENT_NODE)        || (op ==Token.OP_NT_PI && nodetype == Node.PROCESSING_INSTRUCTION_NODE);    }        private boolean NameTest(ExpandedNameNode ExpandedName, Node n)    {        String Namespace_URI = ExpandedName.getNamespaceURI();        String localname = ExpandedName.getLocalName();                boolean ns_is_null = (Namespace_URI==null || Namespace_URI=="");                        //1. LOCAL NAME TEST        if (localname=="*")        {            //Skip name space test            if (ns_is_null)                return true;            //otherwise continue to namespace test        }        //Guaranteed: local name is not *        else if (localname!=n.getLocalName())            //the local name test failed            return false;                //2. NAMESPACE TEST        String node_namespace = n.getNamespaceURI();        boolean node_ns_is_null = (node_namespace==null || node_namespace=="");        if (Namespace_URI==null || Namespace_URI==""){            if (!node_ns_is_null)                return false;        //Guaranteed: Namespace_URI is non-null         }else if (node_ns_is_null || node_namespace!=Namespace_URI)            return false;                //passed all tests so return true        return true;    }    private boolean GeneralComparison(byte op, Object first, Object second)    {        if(first instanceof NodeSet)        {            NodeSet first_ns =(NodeSet) first;            int nodes_count1 = first_ns.getLength();                        if (second instanceof NodeSet)            {                NodeSet second_ns = (NodeSet) second;                int nodes_count2 = second_ns.getLength();                for (int i=0;i<nodes_count1;i++)                    for( int j=0;j<nodes_count2;j++)                        if (AtomComparison(op,                                XPathCoreFunctionLibrary.string_function(first_ns.item(i)),                                XPathCoreFunctionLibrary.string_function(second_ns.item(j))))                            return true;                return false;               } else if (second instanceof Double)            {                for (int i=0;i<nodes_count1;i++)                {                    Double D= XPathCoreFunctionLibrary.number_function(first_ns.item(i));                    if (!D.isNaN()                        && AtomComparison(op,D,second))                        return true;                }                return false;            } else if (second instanceof Boolean)            {                for (int i=0;i<nodes_count1;i++)                {                    if (AtomComparison(op,                            XPathCoreFunctionLibrary.boolean_function(first_ns.item(i)),                            second))                        return true;                }                return false;            } else            {                for (int i=0;i<nodes_count1;i++)                {                    if (AtomComparison(op,                            XPathCoreFunctionLibrary.string_function(first_ns.item(i)),                            second))                        return true;                }                return false;            }                    }        else if (second instanceof NodeSet)        {            NodeSet second_ns = (NodeSet) second;            int nodes_count2 = second_ns.getLength();            if (first instanceof Double)            {                for (int j=0;j<nodes_count2;j++)                {                    Double D= XPathCoreFunctionLibrary.number_function(second_ns.item(j));                    if (!D.isNaN()                        && AtomComparison(op,first,D))                        return true;                }                return false;            }else if (first instanceof Boolean)            {                for (int j=0;j<nodes_count2;j++)                {                    if (AtomComparison(op,                            first,                            XPathCoreFunctionLibrary.boolean_function(second_ns.item(j))))                        return true;                }                return false;            } else            {                for (int j=0;j<nodes_count2;j++)                {                    if (AtomComparison(op,                            first,                            XPathCoreFunctionLibrary.string_function(second_ns.item(j))))                        return true;                }                return false;            }         }        else return AtomComparison(op,first,second);    }        private boolean AtomComparison(byte op, Object first, Object second)    {    switch(op)    {    case Token.OP_EQ:        return AtomEqual(first,second);    case Token.OP_NEQ:        return !AtomEqual(first,second);    case Token.OP_LTE:        return XPathCoreFunctionLibrary.number_function(first).doubleValue()         <= XPathCoreFunctionLibrary.number_function(second).doubleValue();    case Token.OP_LT:        return XPathCoreFunctionLibrary.number_function(first).doubleValue()         < XPathCoreFunctionLibrary.number_function(second).doubleValue();    case Token.OP_GTE:        return XPathCoreFunctionLibrary.number_function(first).doubleValue()         >= XPathCoreFunctionLibrary.number_function(second).doubleValue();    case Token.OP_GT:        return XPathCoreFunctionLibrary.number_function(first).doubleValue()         > XPathCoreFunctionLibrary.number_function(second).doubleValue();    default:        return false;    }    }        private boolean AtomEqual(Object first, Object second)    {        if (first instanceof Boolean          || second instanceof Boolean)        {            boolean b1 = XPathCoreFunctionLibrary.boolean_function(first).booleanValue();            boolean b2 = XPathCoreFunctionLibrary.boolean_function(second).booleanValue();            return b1==b2;        }        else if (first instanceof Double            || second instanceof Double)        {            double d1 = XPathCoreFunctionLibrary.number_function(first).doubleValue();            double d2 = XPathCoreFunctionLibrary.number_function(second).doubleValue();            return d1==d2;         }        else if (first instanceof String            || second instanceof String)        {            String s1 = XPathCoreFunctionLibrary.string_function(first);            String s2 = XPathCoreFunctionLibrary.string_function(second);            return s1.equals(s2);        } else return first.equals(second);    }      /**  * The class result cache is a small cache lookup class for parsenode and results pairs. It features addition  * of parse node and result pair and lookup for results of a certain parse node  * @author galal  *  */       private class ResultCache {    	    	private ParseNode[] m_PN_buffer;    	private Object[] m_results_buffer;    	private int m_pos;    	    	protected ResultCache(int size)    	{    		m_PN_buffer = new ParseNode[size];    		m_results_buffer = new Object[size];    		m_pos = 0;    	}    	    	protected void AddtoCache(ParseNode pn, Object result)    	{    		m_PN_buffer[m_pos] = pn;    		m_results_buffer[m_pos] = result;    		m_pos++;    		if (m_pos==m_PN_buffer.length)m_pos=0;    	}    	    	protected Object LookupCache(ParseNode pn)    	{    		int i = m_pos;    		while (i>=0)    		{    			if (m_PN_buffer[i]==pn)    				return m_results_buffer[i];    			i--;    		}    		i= m_PN_buffer.length -1;    		while (i>m_pos)    		{    			if (m_PN_buffer[i]==pn)    				return m_results_buffer[i];    			i--;    		}    		return null;    	}    	    	protected void ClearCache()    	{    		for (int i = 0; i < m_PN_buffer.length; i++) {    			m_PN_buffer[i]=null;    			m_results_buffer[i]=null;    		}    		m_pos = 0;    	}    }}